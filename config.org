:PROPERTIES:
:ID:       14656706-44e8-4d66-b966-f948a7b85dac
:END:
#+title: My (Doom) Emacs Config
#+author: Mateo Barria-Urenda
#+PROPERTY: header-args :comments

* About
This is my Doom Emacs configuration.

I've separat        ed this file in three main sections, to correspond to Doom's three config files: [[file:init.el]] ([[Modules]]), [[file:config.el]] ([[Config]]), and [[file:packages.el]] ([[Packages]]).
However, these don't correspond one-to-one. [[Config]] consists mostly of changes to stuff included in Doom Emacs (such as configuration of the enabled modules), while [[Packages]] corresponds to installation and configuration of packages not included in Doom modules.

** Why Emacs?

There's a lot of reasons to use Emacs, but most of the ones that matter to me can be grouped as "Unifying my work flow"
- Whether I'm working with Python, LaTeX, or simple text files; I can always use the same keybinds to move around and make changes.
- Whenever I change computers (like between my work computer and my personal computers), I can just use sync my config with git (currently to github).
- Continuing the previous point, if I want access to all my agenda files, I just need to install Dropbox.

This file is an [[https://orgmode.org/][Org Mode]] file, an Emacs mode that has markdown-like features for working with simple text, but also allows for [[https://en.wikipedia.org/wiki/Literate_programming][Literate programming]] with [[https://orgmode.org/worg/org-contrib/babel/][Babel]]. Whenever the term *tangle* comes up, it refers to ~org-babel~'s feature to export blocks of text from an ~org-mode~ file to other files. This was leveraged here to mantain one file for documentation (this one) while keeping actual code in different files (as explained in the [[About]] section).
** Prerequisites
This list might be incomplete. Remember to always run ~doom doctor~ after syncing and/or upgrading Doom Emacs.

| Prereq     | Description                 | Required by                                |
|------------+-----------------------------+--------------------------------------------|
| [[https://commitmono.com/][CommitMono]] | A really nice font.         | My config for doom-font                    |
| [[https://github.com/Nukesor/pueue][pueue]]      | A simple queue for commands | pueue package, to interface with the queue |
| Spotify    | Music Streaming             | emacs-spotify, for obvious reasons         |
| [[https://www.djcbsoftware.nl/code/mu/][mu]]         | Email client                | mu4e                                       |
** Initializing/changing config files
We tangle some comments to each config file.

#+begin_src elisp :tangle init.el
;;; init.el -*- lexical-binding: t; -*-

#+end_src

#+begin_src elisp :tangle packages.el
;; -*- no-byte-compile: t; -*-
;;; $DOOMDIR/packages.el

#+end_src

#+begin_src elisp :tangle config.el
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-

#+end_src

Modifications to [[init.el]] won't take effect until ~doom sync~ is run.
But changes to [[config.el]] and to [[packages.el]] can be applied by reloading the config (~doom/reload~, bound to ~SPC h r r~).

** On installing additional packages in Doom
New packages must be declared in [[file:packages.el]], and if they are in MELPA, ELPA, or emacsmirror they can be installed with ~package!~.

#+begin_example elisp
(package! some-package)
#+end_example

By specifying a ~:recipe~, you can install fom a github repo.

#+begin_example elisp
(package! another-package
  :recipe (:host github :repo "username/repo"))
#+end_example

The recipe will look for a ~PACKAGENAME.el~ file in the project root. If it's not called that of if it's in a subdirectory, it can be specified with ~:files~ (within ~:recipe~).

#+begin_example elisp
(package! this-package
  :recipe (:host github :repo "username/repo"
           :files ("some-file.el" "src/lisp/*.el")))
#+end_example

Included packages can also be disabled, though so far I've had no need of this.

#+begin_example elisp
(package! builtin-package :disable t)
#+end_example

Packages can also be overriden while keeping the ~:recipe~ (either from Doom or MELPA/ELPA/emacsmirror)

#+begin_example elisp
(package! builtin-package :recipe (:nonrecursive t))
(package! builtin-package-2 :recipe (:repo "myfork/package"))
#+end_example

It's also possible to specify a branch or a specific commit.

#+begin_example
(package! builtin-package :recipe (:branch "develop"))
(package! builtin-package :pin "1a2b3c4d5e")
#+end_example

Or to unpin a package, multiple packages, or even all packages (not recommended) to use their latest version.

#+begin_example
(unpin! pinned-package)
(unpin! pinned-package another-pinned-package)
(unpin! t)
#+end_example

** On configuring installed packages.
This is totally copy pasted from the default config.el comments.

#+begin_quote
Whenever you reconfigure a package, make sure to wrap your config in an
`after!' block, otherwise Doom's defaults may override your settings. E.g.

  (after! PACKAGE
    (setq x y))

The exceptions to this rule:

  - Setting file/directory variables (like `org-directory')
  - Setting variables which explicitly tell you to set them before their
    package is loaded (see 'C-h v VARIABLE' to look up their documentation).
  - Setting doom variables (which start with 'doom-' or '+').

Here are some additional functions/macros that will help you configure Doom.

- `load!' for loading external *.el files relative to this one
- `use-package!' for configuring packages
- `after!' for running code after a package has loaded
- `add-load-path!' for adding directories to the `load-path', relative to
  this file. Emacs searches the `load-path' when you load packages with
  `require' or `use-package'.
- `map!' for binding new keys

To get information about any of these functions/macros, move the cursor over
the highlighted symbol at press 'K' (non-evil users must press 'C-c c k').
This will open documentation for it, including demos of how they are used.

Alternatively, use `C-h o' to look up a symbol (functions, variables, faces,
etc).

You can also try 'gd' (or 'C-c c d') to jump to their definition and see how
they are implemented.
#+end_quote

* Modules

** Preface

Doom modules are loaded in ~init.el~.

We can get information on any of them from Doom using ~doom/help-modules~ (~SPC h d m~), or at point with ~+lookup/documentation~ (~K~).

Any changes to this won't take effect until ~doom sync~ is run.

We start by calling doom

#+begin_src elisp :tangle init.el
(doom!
#+end_src

** :input

Doom has input modules to accomodate other languages and keyboards; I don't use any of them.
For the record, these currently include ~bidi~ (right-to-left), ~chinese~, ~japanese~, and ~layout~ (for accomodating different layouts).  

** :completion

For completion at point I use [[https://company-mode.github.io/][company-mode]], and for completion of commands (searching commands, files, directories, etc) I use [[https://github.com/minad/vertico][vertico]].

#+begin_src elisp :tangle init.el
       :completion
       ;; (company +childframe)           ; the ultimate code completion backend
       (corfu +icons +orderless +dabbrev)           ; the ultimate code completion backend
       (vertico +icons +childframe)    ; the search engine of the future

#+end_src

I do not make any further changes to configuration for these modules, but it is important to keep in mind which you have enabled, as they affect many other modules.
Doom also provides modules for [[https://emacs-helm.github.io/helm/][Helm]], [[https://www.gnu.org/software/emacs/manual/html_mono/ido.html][Ido (Interactive Do)]], and [[https://github.com/abo-abo/swiper][Ivy]].

** :ui

We use several of the doom ui modules. These all work great to make Emacs fell more modern.

#+begin_src elisp :tangle init.el
       :ui
       doom              ; what makes DOOM look the way it does
       doom-dashboard    ; a nifty splash screen for Emacs
       modeline          ; snazzy, Atom-inspired modeline, plus API
       workspaces        ; tab emulation, persistence & separate workspaces
#+end_src

Doom by itself has great window navigation (under the ~SPC w~ leader),but the ~window-select~ module makes it even better.

#+begin_src elisp :tangle init.el
       (window-select +numbers)     ; visually switch windows
#+end_src

It also provides some other small tweaks to ui that I really like.
#+begin_src elisp :tangle init.el
       hl-todo           ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW
       indent-guides     ; highlighted indent columns
       ophints           ; highlight the region an operation acts on
       vc-gutter         ; vcs diff in the fringe
       vi-tilde-fringe   ; fringe tildes to mark beyond EOB
       (popup +defaults +all)   ; tame sudden yet inevitable temporary windows
       nav-flash         ; blink cursor line after big motions
#+end_src

Doom also has a module for ligatures, though it requires the use of a compatible font. (TODO: Link to config)

#+begin_src elisp :tangle init.el
       (ligatures +extra)         ; ligatures and symbols to make your code pretty again
#+end_src

And it provides a module for [[https://github.com/Alexander-Miller/treemacs][treemacs.]]  With configuration for language server protocol compatibility. (Alternatively, there's a module for [[https://github.com/jaypei/emacs-neotree][neotree]])
#+begin_src elisp :tangle init.el
       (treemacs +lsp)          ; a project drawer, like neotree but cooler

#+end_src

It should be noted that Doom also provides modules for [[https://jblevins.org/projects/deft/][deft]], emoji support, better unicode support, a quit-message prompt, a minimap, tabs, and a zen mode.

#+begin_src elisp :tangle init.el
       (emoji +ascii  +github +unicode)

#+end_src

** :editor
Of course, we use evil-mode in Doom.
#+begin_src elisp :tangle init.el
       :editor
       (evil +everywhere); come to the dark side, we have cookies
#+end_src

There's modules that help with editing in any language, programming or otherwise.
#+begin_src elisp :tangle init.el
       file-templates    ; auto-snippets for empty files
       fold              ; (nigh) universal code folding
       (format +onsave)  ; automated prettiness
       multiple-cursors  ; editing in many places at once
       rotate-text       ; cycle region at point between text candidates
       snippets          ; my elves. They type so I don't have to
       word-wrap         ; soft wrapping with language-aware indent
#+end_src
For the fold module, note that some useful default bindings are:

| binding | action                    |
|---------+---------------------------|
| ~z a~   | Open/close fold           |
| ~z p~   | Close fold                |
| ~z o~   | Open fold                 |
| ~z j~   | Previous fold             |
| ~z k~   | Next fold                 |
| ~z m~   | Change fold level of area |
| ~z M~   | Close all folds           |
| ~z R~   | Open all folds            |

And there's some modules for programming (Lisp in particular), that I haven't played around with yet, but I'll keep in my config as "someday" comments.
#+begin_src elisp :tangle init.el
       ;;lispy             ; vim for lisp, for people who don't like vim
       ;;objed             ; text object editing for the innocent
       ;;parinfer          ; turn lisp into python, sort of

#+end_src
** :emacs
Doom provides some modules that enhance the vanila emacs experience. I'm all for them.
#+begin_src elisp :tangle init.el
       :emacs
       (dired +icons)             ; making dired pretty [functional]
       electric          ; smarter, keyword-based electric-indent
       (ibuffer +icons)         ; interactive buffer management
       undo              ; persistent, smarter undo for your inevitable mistakes
       vc                ; version-control and Emacs, sitting in a tree

#+end_src

** :term
Doom provides modules for four terminals, [[eshell][eshell]] (built-in elisp shell),  a simple repl shell (the ~shell~ module), term (with multi-term), and [[https://github.com/akermu/emacs-libvterm][vterm]] (the best option).
#+begin_src elisp :tangle init.el
       :term
       vterm             ; the best terminal emulation in Emacs

#+end_src
** :checkers
The doom spell/syntax checkers all work really well. Writegood mode (installed by ~:checkers grammar~) can be a bit annoying when writing formally, but it does no harm to have it activated.
#+begin_src elisp :tangle init.el
       :checkers
       syntax              ; tasing you for every semicolon you forget
       (spell +flyspell) ; tasing you for misspelling mispelling
       grammar           ; tasing grammar mistake every you make

#+end_src
** TODO :tools
Doom has a bunch of modules under ~:tools~ that are really useful.
Biblio allows for better bibliography management.
#+begin_src elisp :tangle init.el
       :tools
       biblio                ; Writes a PhD for you (citation needed)
       editorconfig          ; let someone else argue about tabs vs spaces
       ein                   ; tame Jupyter notebooks with emacs
       (eval +overlay)       ; run code, run (also, repls)
       (lookup +dictionary)  ; navigate your code and its documentation
       lsp                   ; M-x vscode
       magit                 ; a git porcelain for Emacs
       make                  ; run make tasks from Emacs
       (pass +pass)          ; password manager for nerds
       pdf                   ; pdf enhancements
       rgb                   ; creating color strings
       tmux                  ; an API for interacting with tmux
       tree-sitter
       upload                ; map local to remote projects via ssh/ftp

#+end_src

(Note: Eval can be called with ~gr~ on a region)

Doom also provides modules for [[https://www.ansible.com/][Ansible]], debugging, [[https://direnv.net/][direnv]], [[https://www.docker.com/][Docker]], [[https://github.com/rejeep/prodigy.el][prodigy]], [[https://www.terraform.io/][Terraform]]
** :os
Here we just activate ~tty~ module for better terminal experience. There's also a module to improve the MacOS experience; but I don't use Apple products.
#+begin_src elisp :tangle init.el
       :os
       tty               ; improve the terminal Emacs experience

#+end_src
** :lang
Doom has modules to help set it up as an IDE for a variety of programming languages.
Here are the ones I have enabled; the ~+lsp~ and ~+tree-sitter~ options are common and just enable integration with the respective modules.
#+begin_src elisp :tangle init.el
       :lang
       (cc +lsp +tree-stitter)         ; C > C++ == 1
       emacs-lisp        ; drown in parentheses
       (julia +lsp +tree-sitter +snail)             ; a better, faster MATLAB
       (latex +latexmk +cdlatex +lsp +fold)             ; writing papers in Emacs has never been so fun
       (nix +tree-sitter +lsp)               ; I hereby declare "nix geht mehr!"
       (python +lsp +tree-sitter +pyenv)           ; beautiful is better than ugly
       (sh +lsp)               ; she sells {ba,z,fi}sh shells on the C xor
       lua                 ; one-based indices? one-based indices
#+end_src

There's also support for simple text formats (not exactly programming languages, but quite powerfull in their own right).
#+begin_src elisp :tangle init.el
       data              ; config/data formats
       ledger            ; be audit you can be
       markdown          ; writing docs for people to ignore
#+end_src
Org-mode in particular deserves some attention, as it has many more options.
#+begin_src elisp :tangle init.el
       (org                ; organize your plain life in plain text
            +pretty        ; prettier defaults
            +dragndrop     ; drag images to org files
            +gnnuplot      ; Render images from gnuplot / plot org-tables
            +org-noter     ; Take notes of documents
            +hugo          ; Use Hugo to export websites
            +present       ; Use org-mode for presentations
            +roam2         ; A Zettelkasten for Emacs
            +journal       ; for keeping a work diary
            +pomodoro)     ; Use org-mode timers for productivity
#+end_src


Finally, a (commented) list of languages I don't use, as it might be useful in the future.
#+begin_src elisp :tangle init.el
       ;;agda              ; types of types of types of types...
       ;;beancount         ; mind the GAAP
       ;;clojure           ; java with a lisp
       ;;common-lisp       ; if you've seen one lisp, you've seen them all
       ;;coq               ; proofs-as-programs
       ;;crystal           ; ruby at the speed of c
       ;;csharp            ; unity, .NET, and mono shenanigans
       ;;(dart +flutter)   ; paint ui and not much else
       ;;dhall
       ;;elixir            ; erlang done right
       ;;elm               ; care for a cup of TEA?
       ;;erlang            ; an elegant language for a more civilized age
       ;;ess               ; emacs speaks statistics
       ;;factor
       ;;faust             ; dsp, but you get to keep your soul
       ;;fortran           ; in FORTRAN, GOD is REAL (unless declared INTEGER)
       ;;fsharp            ; ML stands for Microsoft's Language
       ;;fstar             ; (dependent) types and (monadic) effects and Z3
       ;;gdscript          ; the language you waited for
       ;;(go +lsp)         ; the hipster dialect
       ;;(graphql +lsp)    ; Give queries a REST
       ;;(haskell +lsp)    ; a language that's lazier than I am
       ;;hy                ; readability of scheme w/ speed of python
       ;;idris             ; a language you can depend on
       ;;json              ; At least it ain't XML
       ;;(java +lsp)       ; the poster child for carpal tunnel syndrome
       ;;javascript        ; all(hope(abandon(ye(who(enter(here))))))
       ;;kotlin            ; a better, slicker Java(Script)
       ;;lean              ; for folks with too much to prove
       ;;nim               ; python + lisp at the speed of c
       ;;ocaml             ; an objective camel
       ;;php               ; perl's insecure younger brother
       ;;plantuml          ; diagrams for confusing people more
       ;;purescript        ; javascript, but functional
       ;;qt                ; the 'cutest' gui framework ever
       ;;racket            ; a DSL for DSLs
       ;;raku              ; the artist formerly known as perl6
       ;;rest              ; Emacs as a REST client
       ;;rst               ; ReST in peace
       ;;(ruby +rails)     ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
       ;;rust              ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
       ;;scala             ; java, but good
       ;;(scheme +guile)   ; a fully conniving family of lisps
       ;;sml
       ;;solidity          ; do you need a blockchain? No.
       ;;swift             ; who asked for emoji variables?
       ;;terra             ; Earth and Moon in alignment for performance.
       ;;web               ; the tubes
       ;;yaml              ; JSON, but readable
       ;;zig               ; C, but simpler

#+end_src
** :email
For email we use mu (with mu4e).
#+begin_src elisp :tangle init.el
       :email
       (mu4e +org +gmail)
#+end_src
There's also a module for [[https://www.emacswiki.org/emacs/NotMuch][NotMuch]] and another for [[https://www.emacswiki.org/emacs/WanderLust][Wanderlust]]. I didn't like NotMuch much, and as of writing, there's basically no documentation for the wanderlust module.
** :app
Doom has a few apps.

Calendar requires an OAuth client ID. TODO: Configure gmail; see also the :email modules.
Everywhere configures [[https://github.com/tecosaur/emacs-everywhere][Emacs Everywhere.]]
And rss adds an rss feed, of course.

#+begin_src elisp :tangle init.el
       :app
       calendar
       everywhere        ; *leave* Emacs!? You must be joking
       (rss +org)        ; emacs as an RSS reader
#+end_src
There's also a module for music plaing (emms) and one for IRC.
** :config
Some meta modules that affect the config itself. Obviously this is a literate config, so it benefits from ~literate~, but I still tangle manually (for some reason when Doom tangles the format is different). ~default~ adds a lot of really nice keybinds (inspired by [[https://www.spacemacs.org/][Spacemacs]])
#+begin_src elisp :tangle init.el
       :config
       ;; literate
       (default +bindings +smartparens)
#+end_src
** End

We finish by closing the doom! list.

#+begin_src elisp :tangle init.el
)
#+end_src

Could've done so in the last module, but didn't want to keep track of that if it happens to change.

* Config

** On package reconfiguration...

Since Doom configures a bunch of stuff, it's important to use ~after!~ to configure packages.

#+begin_example elisp
(after! PACKAGE
    (setq x y))
#+end_example

The expection to this is paths to files/directories, doom variables (prepended with either ~doom~ or ~+~), and of course, variables that are explicitly required to be set up before loading their package.

Other useful macros (copy-pasted from the default config.el that comes with doom)

#+begin_example
 - `load!' for loading external *.el files relative to this one
 - `use-package!' for configuring packages
 - `after!' for running code after a package has loaded
 - `add-load-path!' for adding directories to the `load-path', relative to
   this file. Emacs searches the `load-path' when you load packages with
   `require' or `use-package'.
 - `map!' for binding new keys

 To get information about any of these functions/macros, move the cursor over
 the highlighted symbol at press 'K' (non-evil users must press 'C-c c k').
 This will open documentation for it, including demos of how they are used.
 Alternatively, use `C-h o' to look up a symbol (functions, variables, faces,
 etc).
#+end_example

** Basic configuration

*** Personal information

Some personal information is accesed by GPG configuration, emails clients, snippets, etc...
(This is optional)

#+begin_src elisp :tangle config.el
(setq user-full-name "Mateo Barria-Urenda"
      user-mail-address "mateobarria@gmail.com")
#+end_src
*** Fonts
I use the [[https://commitmono.com/][CommitMono]] font.

#+begin_src elisp :tangle config.el
;; Fonts
(setq doom-font (font-spec :family "CommitMono" :size 14) ; Primary font
      doom-variable-pitch-font (font-spec :family "DejaVu Sans" :size 15) ; non-monospace where applicable
      doom-serif-font (font-spec :family "CommitMono") ; for 'fixed-pitch-serif' face
      doom-big-font (font-spec :family "CommitMono" :size 24)) ; for big font mode ('SPC t b')
#+end_src
*** Theme
I *really* like the [[https://github.com/catppuccin/catppuccin][catppuccin]] theme.

#+begin_src elisp :tangle packages.el
(package! catppuccin-theme)
#+end_src

I use the frappe "flavor" of catppuccin.

#+begin_src elisp :tangle config.el
(setq catppuccin-flavor 'frappe) ;; 'frappe or 'latte, 'macchiato, or 'mocha
(setq catppuccin-highlight-matches t)
(setq catppuccin-italic-comments t)
(setq catppuccin-italic-blockquotes t)
(setq doom-theme 'catppuccin)
#+end_src
**** Treemacs Colors
Set treemacs to use doom colors.
#+begin_src elisp :tangle config.el
(setq doom-themes-treemacs-theme "doom-colors")
#+end_src
**** hl-todo-mode
I like to highlight TODOs regardless of mode, so I can see comments that say TODO.
#+begin_src elisp :tangle config.el
(global-hl-todo-mode)
#+end_src

*** Modeline config
Doom's modeline exposes some configuration.
I change some defaults mostly because sometimes I use [[EXWM]] as my window manager and desktop environment.

#+begin_src elisp :tangle config.el
(display-battery-mode)
(display-time-mode)
(timeclock-mode-line-display)
#+end_src
*** Line Numbers
I use absolute line numbers by default, as I jump to lines using ~numpad+G~.

#+begin_src elisp :tangle config.el
(setq display-line-numbers-type t)
#+end_src

Line numbers can be turned off or switched to relative numbers (for easier navigation with ~number+jk~) by setting ~display-line-numbers~ to ~nil~ or ~relative~, respectively.

*** Splash Image
Previously I used the cover of Zutomayo's [[https://en.wikipedia.org/wiki/Tadashii_Itsuwari_Kara_no_Kish%C5%8D][Tadashii Itsuwari Kara no Kish≈ç]] album, with the blue set to transparent.
Now I'm using a drawing by [[https://www.instagram.com/gharliera/][gharliera/gharly]], with modified colors.
I've seen two ways of setting the splash image and I'm not sure of the difference so for now here's both.

#+begin_src elisp :tangle config.el
(setq fancy-splash-image (concat doom-user-dir "TransparentGNU_catpuccin.png"))
(setq +doom-dashboard-banner-dir doom-user-dir )
(setq +doom-dashboard-banner-file "TransparentGNU_catpuccin.png")
#+end_src

*** Snipe
I like setting evil-snipe to visible.
#+begin_src elisp :tangle config.el
(setq evil-snipe-scope 'visible)
#+end_src
** Org-mode
*** Teco's branch
[[https://git.tecosaur.net/tec][Tecosaur]] has made a lot of improvements to latex preview, and [[https://abode.karthinks.com/org-latex-preview/][Karthink]] set up a tutorial for how to switch to that branch.

#+begin_src elisp :tangle packages.el
(package! org :recipe
  (:host nil :repo "https://git.tecosaur.net/mirrors/org-mode.git" :remote "mirror" :fork
         (:host nil :repo "https://git.tecosaur.net/tec/org-mode.git" :branch "dev" :remote "tecosaur")
         :files
         (:defaults "etc")
         :build t :pre-build
         (with-temp-file "org-version.el"
           (require 'lisp-mnt)
           (let
               ((version
                 (with-temp-buffer
                   (insert-file-contents "lisp/org.el")
                   (lm-header "version")))
                (git-version
                 (string-trim
                  (with-temp-buffer
                    (call-process "git" nil t nil "rev-parse" "--short" "HEAD")
                    (buffer-string)))))
             (insert
              (format "(defun org-release () \"The release version of Org.\" %S)\n" version)
              (format "(defun org-git-version () \"The truncate git commit hash of Org mode.\" %S)\n" git-version)
              "(provide 'org-version)\n"))))
  :pin nil)

(unpin! org)
#+end_src

*** Org Config
I keep my org files in my Dropbox folder, which I always keep or link to in my home directory.
In it, in keep most transient notes in an ~!nbox~ file. (The ! helps keep it on top of sorts by name)
#+begin_src elisp :tangle config.el
(setq org-directory "~/org/")
(setq +org-capture-inbox-file (doom-path org-directory "!nbox.org"))
(setq +org-capture-log-file (doom-path org-directory "work-log.org"))
(setq +org-capture-projects-file (doom-path org-directory "projects.org"))
;; (setq +org-capture-notes-file (doom-path org-directory "!nbox.org"))
;; timestamp DONEs
(setq org-log-done 'time)
#+end_src

**** Templates

#+begin_src elisp :tangle config.el
(after! org
(setq org-capture-templates
      '(
        ("l" "Work Log Entry"
         entry (file+datetree +org-capture-log-file)
         "* %<%R> %?"
         :empty-lines 0
         :tree-type week)
        ("n" "Personal Note"
         entry (file+headline +org-capture-inbox-file "Notes")
           "* %u %?\n%i\n%a"
           :prepend t
         :empty-lines 0)
        ("t" "General To-Do"
         entry (file+headline +org-capture-inbox-file "Tasks")
         "* TODO [#B] %?\n:Created: %T\n%i\n%a"
         :prepend t
         :empty-lines 0)
        ("e" "Email"
         entry (file+headline +org-capture-inbox-file "Emails")
         "* TODO [#B] %?\n:Created: %T\n** Correspondent(s)\n***\n** Notes\n** Sub-actions \n%a"
         :prepend t
         :empty-lines 0)
        ("p" "Project"
         entry (file +org-capture-projects-file)
         "* PROJ [#B] %?\n:Created: %T\n** Collaborators(s)\n***\n** Notes\n** [0%]Actions \n*** TODO\n%a"
         :prepend t
         :empty-lines 0)
        ("m" "Meeting"
         entry (file+datetree "~/org/meetings.org")
         "* %? :meeting:%^g \n:Created: %T\n** Attendees\n*** \n** Notes\n** Action Items\n*** TODO [#A] "
         :tree-type week
         :empty-lines 0)
        )))
#+end_src

**** Priorities
#+begin_src elisp :tangle config.el
(after! org-fancy-priorities
  (setq org-fancy-priorities-list '((?A . "üî¥")
                                  (?B . "üü†")
                                  (?C . "üü¢"))))
#+end_src
**** Tags

#+begin_src elisp :tangle config.el
(setq org-tag-alist '(
                      ;; Ticket types
                      (:startgroup . nil)
                      ("@bug" . ?b)
                      ("@feature" . ?f)
                      (:endgroup . nil)

                      ;; Ticket flags
                      ("@emergency" . ?e)
                      ("@research" . ?r)

                      ;; Special tags
                      ("CRITICAL" . ?x)
                      ("obstacle" . ?o)

                      ;; Meeting tags
                      ("meeting" . ?m)
                      ("misc" . ?z)
                      ("planning" . ?p)
                      ("progress" . ?s)

                      ;; Context Tags
                      (:startgroup . nil)
                      ("personal" . ?g)
                      ("work" . ?t)
                      (:endgroup . nil)

                      ;; Work Log Tags
                      ("accomplishment" . ?a)
                      ))
;; Tag colors
(setq org-tag-faces
      '(
        ("work"  . (:foreground "mediumPurple1" :weight bold))
        ("planning"   . (:foreground "royalblue1"    :weight bold))
        ("progress"  . (:foreground "forest green"  :weight bold))
        ("personal"        . (:foreground "sienna"        :weight bold))
        ("meeting"   . (:foreground "yellow1"       :weight bold))
        ("CRITICAL"  . (:foreground "red1"          :weight bold))
        )
      )
#+end_src

**** Agenda

#+begin_src elisp :tangle config.el
;; Agenda View "d"
(defun air-org-skip-subtree-if-priority (priority)
  "Skip an agenda subtree if it has a priority of PRIORITY.

  PRIORITY may be one of the characters ?A, ?B, or ?C."
  (let ((subtree-end (save-excursion (org-end-of-subtree t)))
        (pri-value (* 1000 (- org-lowest-priority priority)))
        (pri-current (org-get-priority (thing-at-point 'line t))))
    (if (= pri-value pri-current)
        subtree-end
      nil)))

(setq org-agenda-skip-deadline-if-done t)

(after! org-agenda
(setq org-agenda-custom-commands
      '(
        ;; Daily Agenda & TODOs
        ("d" "Daily agenda and all TODOs"

         ;; Display items with priority A
         ((tags "PRIORITY=\"A\""
                ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                 (org-agenda-overriding-header "High-priority unfinished tasks:")))

          ;; View 7 days in the calendar view
          (agenda "" ((org-agenda-span 7)))

          ;; Display items with priority B (really it is view all items minus A & C)
          (alltodo ""
                   ((org-agenda-skip-function '(or (air-org-skip-subtree-if-priority ?A)
                                                   (air-org-skip-subtree-if-priority ?C)
                                                   (org-agenda-skip-if nil '(scheduled deadline))))
                    (org-agenda-overriding-header "ALL normal priority tasks:")))

          ;; Display items with pirority C
          (tags "PRIORITY=\"C\""
                ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                 (org-agenda-overriding-header "Low-priority Unfinished tasks:")))
          )

         ;; Don't compress things (change to suite your tastes)
         ((org-agenda-compact-blocks nil)))
        )))
#+end_src

**** Refiling
Let's make it so that refiling leaves some mark.
Useful for refilign from meetings to projects.
But with an exception for the inbox.
#+begin_src elisp :tangle config.el
(defun org-refile--insert-link ( &rest _ )
  (unless (string-suffix-p "!nbox.org" buffer-file-name)
    (org-back-to-heading)
    (let* ((refile-region-marker (point-marker))
           (source-link (org-store-link nil)))
      (org-insert-heading)
      (insert source-link)
      (goto-char refile-region-marker))))
#+end_src
*** Org-roam
I keep ~org-roam~ updated, and I make use of ~org-roam-ui~ to visualize my notes.
#+begin_src elisp :tangle packages.el
(unpin! org-roam)
(package! org-roam-ui)
#+end_src

My capture templates are for my personal notes (main), notes on specific sources (reference) and on videos (video). 
#+begin_src elisp :tangle config.el
(after! org-roam-capture
(setq org-roam-capture-templates
      '(("m" "main" plain
         "%?"
         :if-new (file+head "main/${slug}.org"
                            "#+title: ${title}\n#+filetags:\n#+date: %u\n#+lastmod: %u\n\n")
         :immediate-finish t
         :unnarrowed t)
        ("r" "reference" plain
         "%?"
         :if-new (file+head "reference/${title}.org"
                            "#+title: ${title}\n#+filetags: :Reference:\n#+date: %u\n#+lastmod: %u\n\n")
         :immediate-finish t
         :unnarrowed t)
        ("b" "bibliography" plain
         "%?"
         :if-new (file+head "bibliography/${citar-citekey}.org"
                            "#+title: ${title}\n#+filetags: :Bibliography:\n#+date: %u\n#+lastmod: %u\n\n- authors :: ${citar-author}\n- date :: ${citar-date}\n- DOI :: [[https://dx.doi.org/${citar-doi}][${citar-doi}]]\n- tags ::\n")
         :immediate-finish t
         :unnarrowed t)
        ("v" "video" plain
         "%?"
         :if-new (file+head "videos/${title}.org"
                            "#+title: ${title}\n#+filetags: :Video: \n#+date: %u\n#+lastmod: %u\n\n")
         :immediate-finish t
         :unnarrowed t))))
#+end_src

#+RESULTS:
| m | main | plain | %? | :if-new | (file+head main/${slug}.org #+title: ${title} |

I stole [[https://jethrokuan.github.io/org-roam-guide/][jethrokuan's]] code for prettier note searching.
It stopped working for some reason. So I'm temporarily untangling this.
#+begin_src elisp
;; Add property "type" to notes
;; (cl-defmethod org-roam-node-type ((node org-roam-node))
;;   "Return the TYPE of NODE."
;;   (condition-case nil
;;       (file-name-nondirectory
;;        (directory-file-name
;;         (file-name-directory
;;          (file-relative-name (org-roam-node-file node) org-roam-directory))))
;;     (error "")))
;; ;; Add this property to displays
;; (setq org-roam-node-display-template
;;       (concat "${type:15} ${title:*} " (propertize "${tags:10}" 'face 'org-tag)))
;; ;; auto tag new notes as drafts
;; (defun jethro/tag-new-node-as-draft ()
;;   (org-roam-tag-add '("draft")))
;; (add-hook 'org-roam-capture-new-node-hook #'jethro/tag-new-node-as-draft)
#+end_src

I use ~org-roam-protocol~ which requires some [[https://www.orgroam.com/manual.html#org_002droam_002dprotocol][setup.]]
#+begin_src elisp :tangle config.el
(require 'org-roam-protocol)
#+end_src
And org-roam-ui with the folloing config:
#+begin_src elisp :tangle config.el
(use-package! websocket
  :after org-roam)

(use-package! org-roam-ui
  :after org-roam ;; or :after org
  ;;         normally we'd recommend hooking orui after org-roam, but since org-roam does not have
  ;;         a hookable mode anymore, you're advised to pick something yourself
  ;;         if you don't care about startup time, use
  :hook (after-init . org-roam-ui-mode)
  :config
  (setq org-roam-ui-sync-theme t
        org-roam-ui-follow t
        org-roam-ui-update-on-save t
        org-roam-ui-open-on-start nil))
#+end_src
*** Bibliograhy
I try to keep an organised bibliography using Org Babel.
And I want access in Emacs to the .bib entries tangled from it.
Citar lets me acces my bibiography from anywhere.
It also lets me access notes (~citar-open-notes~), pdfs (~citar-open-files~), and the bibtex entry themselves (~citar-open-entry~).

Doom's biblio module already binds some functions, but I found that opening files and inserting citations (which works both in org-mode and TeX mode) were some glaring omissions. Here I also set up my bibliography files that I want to be able to access anywhere.
The "reference" folder is mostly set up as a fallback. I try to keep my notes in a single Bibliography.org file.

#+begin_src elisp :tangle config.el
(require 'oc-bibtex)
(after! citar
  (setq! citar-bibliography '(
                              "/home/mbarria/org/Bib/biochem.bib"
                              "/home/mbarria/org/Bib/biology.bib"
                              "/home/mbarria/org/Bib/forcefields.bib"
                              "/home/mbarria/org/Bib/free_energy.bib"
                              "/home/mbarria/org/Bib/graphene.bib"
                              "/home/mbarria/org/Bib/md_software.bib"
                              "/home/mbarria/org/Bib/md_theory.bib"
                              "/home/mbarria/org/Bib/membranes.bib"
                              "/home/mbarria/org/Bib/nano_other.bib"
                              "/home/mbarria/org/Bib/nanotubes.bib"
                              "/home/mbarria/org/Bib/orgchem.bib"
                              "/home/mbarria/org/Bib/physics.bib"
                            ))
  (setq org-cite-global-bibliography citar-bibliography)
  (setq! citar-library-paths '("/home/mbarria/org/roam/pdfs/"))
  (setq! citar-notes-paths '("/home/mbarria/org/roam/reference/"))
  (setq! citar-library-file-extensions  (list "pdf"))
  )

  (map! :map doom-leader-notes-map
        :desc "Insert Citation" "p" 'citar-insert-citation
        :desc "Open Reference" "P" 'citar-open)

;; org-roam + citar config
(after! citar-org-roam
        (setq citar-org-roam-subdir "bibliography")
        (setq citar-org-roam-note-title-template "${title}")
        (setq citar-org-roam-capture-template-key "b")
        (setq citar-org-roam-template-fields
        '((:citar-title . ("title"))
        (:citar-author . ("author" "editor"))
        (:citar-date . ("date" "year" "issued"))
        (:citar-doi . ("doi"))
        (:citar-pages . ("pages"))
        (:citar-type . ("=type="))))
              )
#+end_src

#+RESULTS:
| :citar-title  | title  |        |        |
| :citar-author | author | editor |        |
| :citar-date   | date   | year   | issued |
| :citar-doi    | doi    |        |        |
| :citar-pages  | pages  |        |        |
| :citar-type   | =type= |        |        |

I also keep a longer Bibliography file which I want to access in my LaTeX projects, so I make sure reftex knows about it.

#+begin_src elisp :tangle config.el
(after! reftex
  (setq! reftex-default-bibliography '("/home/mbarria/org/Bib/Bibliography.bib"))
  )
#+end_src

This is kinda redundant though, since I've switched to just running ~citar-export-local-bib-file~ in my latex projects. 

To manage my bibliography files I run this function (which I don't remember where I copied it from) to get a bibtex entry from a DOI.
#+begin_src elisp :tangle config.el
(defun get-bibtex-from-doi (doi)
  "Get a BibTeX entry from the DOI"
  (interactive "MDOI: ")
  (let ((url-mime-accept-string "text/bibliography;style=bibtex"))
    (with-current-buffer
        (url-retrieve-synchronously
         (format "http://dx.doi.org/%s"
       	         (replace-regexp-in-string "http://dx.doi.org/" "" doi)))
      (switch-to-buffer (current-buffer))
      (goto-char (point-max))
      (setq bibtex-entry
     	    (buffer-substring
             (string-match "@" (buffer-string))
             (point)))
      (kill-buffer (current-buffer))))
  (insert (decode-coding-string bibtex-entry 'utf-8))
  (bibtex-fill-entry))
#+end_src
*** Async babel
ob-sync allows for running babel code blocks asynchronously.
#+begin_src elisp :tangle packages.el
(package! ob-async
  :recipe (:host github
           :repo "astahlman/ob-async"))
#+end_src

#+begin_src elisp :tangle config.el
(use-package! ob-async)
#+end_src

To use, just include ~:async~ in the header-args.

*** Auto git mode
Technically not org-mode related, but I enable it in my org directory.
#+begin_src elisp :tangle packages.el
(package! git-auto-commit-mode)
#+end_src

Enable it in a directory with a ~dir-locals.el~ file.

#+begin_src elisp :tangle ~/org/.dir-locals.el
((nil . ((eval git-auto-commit-mode 1))))
#+end_src
*** Auto update lastmod
Update property ~lastmod~ when saving files.
From [[https://org-roam.discourse.group/t/update-a-field-last-modified-at-save/321/5][Zaeph]]
#+begin_src elisp :tangle config.el
  ;;--------------------------
  ;; Handling file properties for ‚ÄòCREATED‚Äô & ‚ÄòLAST_MODIFIED‚Äô
  ;;--------------------------

  (defun zp/org-find-time-file-property (property &optional anywhere)
    "Return the position of the time file PROPERTY if it exists.

When ANYWHERE is non-nil, search beyond the preamble."
    (save-excursion
      (goto-char (point-min))
      (let ((first-heading
             (save-excursion
               (re-search-forward org-outline-regexp-bol nil t))))
        (when (re-search-forward (format "^#\\+%s:" property)
                                 (if anywhere nil first-heading)
                                 t)
          (point)))))

  (defun zp/org-has-time-file-property-p (property &optional anywhere)
    "Return the position of time file PROPERTY if it is defined.

As a special case, return -1 if the time file PROPERTY exists but
is not defined."
    (when-let ((pos (zp/org-find-time-file-property property anywhere)))
      (save-excursion
        (goto-char pos)
        (if (and (looking-at-p " ")
                 (progn (forward-char)
                        (org-at-timestamp-p 'lax)))
            pos
          -1))))

  (defun zp/org-set-time-file-property (property &optional anywhere pos)
    "Set the time file PROPERTY in the preamble.

When ANYWHERE is non-nil, search beyond the preamble.

If the position of the file PROPERTY has already been computed,
it can be passed in POS."
    (when-let ((pos (or pos
                        (zp/org-find-time-file-property property))))
      (save-excursion
        (goto-char pos)
        (if (looking-at-p " ")
            (forward-char)
          (insert " "))
        (delete-region (point) (line-end-position))
        (let* ((now (format-time-string "[%Y-%m-%d %a %H:%M]")))
          (insert now)))))

  (defun zp/org-set-last-modified ()
    "Update the LAST_MODIFIED file property in the preamble."
    (when (derived-mode-p 'org-mode)
      (zp/org-set-time-file-property "lastmod")))


#+end_src

#+RESULTS:

** Ligatures
*** Julia
Last I checked, the ligatures module doesn't include julia.
So I set those up.
#+begin_src elisp :tangle config.el
;; Julia
(after! julia-mode
  (set-ligatures! 'julia-mode
    ;; Functional
    :lambda        "->"
    :def           "function"
    :composition   "struct"
    :map           "Dict"
    ;; Types
    :null          "Nothing"
    :true          "true"
    :false         "False"
    :int           "Int"
    :float         "Float64"
    :str           "String"
    :bool          "Bool"
    ;; Flow
    :not           "!"
    :in            "in"
    :not-in        "!in"
    :and           "and"
    :or            "or"
    :for           "for"
    :some          "some keyword"
    :return        "return"
    ;; Other
    :union         "union"
    :intersect     "intersect"
    :pipe          "|>" 
    )
  )
#+end_src

** Ledger
The ledger module configures pretty much everything I need. I just add a binding to access my ledger.
#+begin_src elisp :tangle config.el
(map! :map doom-leader-notes-map
      :desc "Ledger" "e" (cmd! (find-file (doom-path org-directory "ledger.org"))))
#+end_src

** \LaTeX
I like how tex-fold looks, but I find it weird that it only recognizes the base ~\\cite~ command.

#+begin_src elisp :tangle config.el
(after! tex-fold
  (add-to-list 'TeX-fold-macro-spec-list '("[c]" ("cite" "bibitem" "citep" "citet" "autocite" "fullcite")))
  )
#+end_src


** mu4e
mu4e requires some external config. The docs for the Doom module are really helpful and without them I couldn't have set it up for myself.

My config is nothing special. 

#+begin_src elisp :tangle config.el
;; Each path is relative to the path of the maildir you passed to mu
(set-email-account! "gmail"
                    '((mu4e-sent-folder       . "/gmail/[Gmail]/Enviados")
                      (mu4e-drafts-folder     . "/gmail/[Gmail]/Borradores")
                      (mu4e-trash-folder      . "/gmail/[Gmail]/Papelera")
                      (mu4e-refile-folder     . "/gmail/[Gmail]/Todos")
                      (smtpmail-smtp-user     . "mateobarria@gmail.com")
                      (user-mail-address      . "mateobarria@gmail.com")    ;; only needed for mu < 1.4
                      (mu4e-compose-signature . "---\nSaludos,\n\nMateo Barr√≠a\n\n(Sent with Mu4e)"))
                    t)

(setq org-msg-signature "\nMateo Barria-Urenda\n\n(Sent with Mu4e+Org-msg)")

(setq +mu4e-gmail-accounts '(("mateobarria@gmail.com" . "/mateobarria")))
;; don't need to run cleanup after indexing for gmail
(setq mu4e-index-cleanup nil
      ;; because gmail uses labels as folders we can use lazy check since
      ;; messages don't really "move"
      mu4e-index-lazy-check t)
(setq mu4e-update-interval 60)
#+end_src
** Julia
While I'm most proficient with Python, I'm trying to switch to Julia whenever possible.

*** LSP Configuration

Tell ~lsp-julia~ where ~LanguageServer~ is explicitly

#+begin_src elisp :tangle config.el

(after! lsp-julia
  (setq lsp-julia-package-dir nil)
  (setq lsp-julia-default-environment "~/.julia/environments/v1.10"))
#+end_src

#+RESULTS:
: ~/.julia/environments/v1.10

** projectile

#+begin_src elisp :tangle config.el

(after! projectile
 (setq projectile-project-search-path '("~/Projects/" "~/Code/" ("~/Lab" . 1))) )
#+end_src
** Shell
Set vterm to nushell
#+begin_src elisp :tangle config.el
(setq nu--path  "/etc/profiles/per-user/mbarria/bin/nu")
(if (file-exists-p nu--path)
    (setq vterm-shell nu--path))
#+end_src
** pandoc
Take advantage of [[https://pandoc.org/][Pandoc]] to never leave org-mode!

#+begin_src elisp :tangle packages.el
(package! org-pandoc-import
  :recipe (:host github
           :repo "tecosaur/org-pandoc-import"
           :files ("*.el" "filters" "preprocessors")))
(package! ox-pandoc)
#+end_src

#+begin_src elisp :tangle config.el
(use-package! org-pandoc-import :after org)
(use-package! ox-pandoc :after org)
#+end_src
* Packages

** Spotify

Possibly peak "I don't want to leave Emacs" for me is controlling Spotify.
These's multiple packages that do this, but I use SnootierMoon's [[https://github.com/SnootierMoon/emacs-spotify][emacs-spotify]].
#+begin_src elisp :tangle packages.el
(package! spotify
  :recipe (:host github
           :repo "SnootierMoon/emacs-spotify"))
#+end_src
Which I bind to it's own prefix map after the Doom leader.
#+begin_src elisp :tangle config.el
(map! :leader
      (:prefix-map ("S" . "Spotify")
       :desc "START"    "s" 'spotify-start
       :desc "Play"     "j" 'spotify-play
       :desc "Pause"    "k" 'spotify-pause
       :desc "Next"     "l" 'spotify-next
       :desc "Previous" "h" 'spotify-prev
       ))
#+end_src
** Pueue
[[https://github.com/Nukesor/pueue][Pueue]] is a super useful tool for running data analysis and other long processes.
I find it very useful to open and add to the queue from Emacs, particularly when working with python/julia scripts.
#+begin_src elisp :tangle packages.el
(package! pueue
  :recipe (:host github
           :repo "xFA25E/pueue"))
#+end_src
I add a binding to the open map too see how everything is doing, and another to the code map to easily add scripts I'm looking at to the queue.
#+begin_src elisp :tangle config.el
;; Pueue
(map! :map doom-leader-open-map
      :desc "Pueue"     "q" 'pueue
      )
(map! :map doom-leader-code-map
      :desc "Add to Pueue"     "q" 'pueue-add
      )
#+end_src
** Beacon
A small but powerfull change: a big beacon of light whenever you switch windows/buffers.
#+begin_src elisp :tangle packages.el
(package! beacon)
#+end_src
Of course, I ant it to be always active.
#+begin_src elisp :tangle config.el
(use-package! beacon
  :config (beacon-mode 1))
#+end_src
** Nyan-mode
Add a bit of life to the modeline.
#+begin_src elisp :tangle packages.el
(package! nyan-mode)
#+end_src

#+begin_src elisp :tangle config.el
(use-package! nyan-mode
  :after doom-modeline
  :config
  (setq nyan-bar-length 15
        nyan-wavy-trail t)
  (nyan-mode)
  (nyan-start-animation))
#+end_src
** EXWM
Emacs is not my main window manager currently, but I like to play around with [[https://github.com/ch11ng/exwm][EXWM]] every so often.

#+begin_src elisp :tangle packages.el
(package! exwm)
#+end_src

Most of my config is from EXWM's config. Comments included

#+begin_src elisp :tangle config.el
;; All buffers created in EXWM mode are named "*EXWM*". You may want to
;; change it in `exwm-update-class-hook' and `exwm-update-title-hook', which
;; are run when a new X window class name or title is available.  Here's
;; some advice on this topic:
;; + Always use `exwm-workspace-rename-buffer` to avoid naming conflict.
;; + For applications with multiple windows (e.g. GIMP), the class names of
;;    all windows are probably the same.  Using window titles for them makes
;;   more sense.
;; In the following example, we use class names for all windows except for
;; Java applications and GIMP.
(require 'exwm)
(require 'exwm-config)
(setq exwm-workspace-number 4)
(add-hook 'exwm-update-class-hook
          (lambda ()
            (unless (or (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                        (string= "gimp" exwm-instance-name))
              (exwm-workspace-rename-buffer exwm-class-name))))
(add-hook 'exwm-update-title-hook
          (lambda ()
            (when (or (not exwm-instance-name)
                      (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                      (string= "gimp" exwm-instance-name))
              (exwm-workspace-rename-buffer exwm-title))))
#+end_src

My bindings are pretty close to the examples too.

#+begin_src elisp :tangle config.el
;; Global keybindings can be defined with `exwm-input-global-keys'.
;; Here are a few examples:
(setq exwm-input-global-keys
      `(
        ;; Bind "s-r" to exit char-mode and fullscreen mode.
        ([?\s-r] . exwm-reset)
        ;; Bind "s-w" to switch workspace interactively.
        ([?\s-w] . exwm-workspace-switch)
        ;; Bind "s-0" to "s-9" to switch to a workspace by its index.
        ,@(mapcar (lambda (i)
                    `(,(kbd (format "s-%d" i)) .
                      (lambda ()
                        (interactive)
                        (exwm-workspace-switch-create ,i))))
                  (number-sequence 0 9))
        ;; Bind "s-&" to launch applications ('M-&' also works if the output
        ;; buffer does not bother you).
        ([?\s-t] . (lambda (command)
		     (interactive (list (read-shell-command "$ ")))
		     (start-process-shell-command command nil command)))
        ;; Bind "s-<f2>" to "slock", a simple X display locker.
        ([s-f2] . (lambda ()
		    (interactive)
		    (start-process "" nil "/usr/bin/slock")))))

;; To add a key binding only available in line-mode, simply define it in
;; `exwm-mode-map'.  The following example shortens 'C-c q' to 'C-q'.
(define-key exwm-mode-map [?\C-q] #'exwm-input-send-next-key)

;; The following example demonstrates how to use simulation keys to mimic
;; the behavior of Emacs.  The value of `exwm-input-simulation-keys` is a
;; list of cons cells (SRC . DEST), where SRC is the key sequence you press
;; and DEST is what EXWM actually sends to application.  Note that both SRC
;; and DEST should be key sequences (vector or string).
(setq exwm-input-simulation-keys
      '(
        ;; movement
        ([?\C-b] . [left])
        ([?\M-b] . [C-left])
        ([?\C-f] . [right])
        ([?\M-f] . [C-right])
        ([?\C-p] . [up])
        ([?\C-n] . [down])
        ([?\C-a] . [home])
        ([?\C-e] . [end])
        ([?\M-v] . [prior])
        ([?\C-v] . [next])
        ([?\C-d] . [delete])
        ([?\C-k] . [S-end delete])
        ;; cut/paste.
        ([?\C-w] . [?\C-x])
        ([?\M-w] . [?\C-c])
        ([?\C-y] . [?\C-v])
        ;; search
        ([?\C-s] . [?\C-f])))
#+end_src

Normally you'd enable exwm but on my nix system's where I use it I have my Nix config set to handle that, so it doesn't raise issues in computers where I haven't done the rest of the canfiguring. 

Finally some config to work with evil and the doom leader.

#+begin_src elisp :tangle config.el
(add-hook!  'exwm-manage-finish-hook 'evil-emacs-state)
(push ?\M-\  exwm-input-prefix-keys)
#+end_src


*** desktop-environment
[[https://github.com/DamienCassou/desktop-environment][desktop-environment]] makes it easy to use media control keys, specially in EXWM.

#+begin_src elisp :tangle packages.el
(package! desktop-environment
  :recipe (:host github
           :repo "DamienCassou/desktop-environment"))
#+end_src

#+begin_src elisp :tangle config.el
(use-package! desktop-environment
  :after exwm
  :config
  (setq desktop-environment-screenshot-command "flameshot gui")
  (desktop-environment-mode))
#+end_src
 
*** randr

To use multiple screens with EXWM you need to do some config.

#+begin_src elisp :tangle config.el
(require 'exwm-randr)
(setq exwm-randr-workspace-monitor-plist '(0 "HDMI-1"))
(add-hook 'exwm-randr-screen-change-hook
          (lambda ()
            (start-process-shell-command
             "xrandr" nil "xrandr --output HDMI-1 --right-of eDP-1 --auto")))
(exwm-randr-enable)
#+end_src


# ** Discord rich presence
# Not really useful but a fun thing to enable. [[https://github.com/Mstrodl/elcord][elcord]] sets up discord integration.

# #+begin_src elisp :tangle packages.el
# (package! elcord)
# #+end_src

# #+begin_src elisp :tangle config.el
# (use-package! elcord
#   :config
#   (setq elcord-editor-icon "emacs_material_icon")
#   ;; (elcord-mode)
#   )
# #+end_src
